/**
 * @file     hammer_pattern.cpp
 *
 * @brief    Handles the creation of hammer patterns.
 *
 * If USE_ASMJIT is specified in CMAKE, "blacksmith" is
 * specified as hammer_algorithm in the 'config.ini' and hammer_order is not
 * empty the number of aggressor_rows is specified by the program, depending on
 * the highest id in the hammer_order. If a 'x' is specified in the
 * hammer_pattern the hammer pattern is constructed with random row distances on
 * the position of 'x'. The specified hammer_pattern is repeated until the
 * aggressor rows in the pattern match the number of aggressor_rows specified in
 * 'config.ini' or by the Blacksmith's hammer_order. Furthermore row_padding is
 * used to add a buffer in the front and end of the pattern, so no adjacent
 * pages get hammered, resulting in an unexpected behavior.
 *
 */

#include <algorithm>
#include <chrono>
#include <cstdlib>
#include <random>
#include <regex>

#include "config.h"
#include "hammer_pattern.h"
#include "logging.h"

/**
 * @brief    Generates the values of the random row distances in the hammer
 *           pattern (x).
 *
 * At first random values are generated, then scaled to fit the sum of the
 * random values into the random area and afterwards filled up with the
 * remaining difference due to rounding errors. In the last step, the difference
 * is added by the value of 1 to a random value until the difference is 0.
 *
 * @param    needed_random_area  The area to fill with random values.
 * @param    needed_random_value_count The needed number of random values.
 * @return   std::vector<uint64_t> The random values.
 */
std::vector<uint64_t> HammerPattern::generate_random_fill_up(
    uint64_t needed_random_area, uint64_t needed_random_value_count) const {
  // initialize random generator and distribution
  unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
  std::default_random_engine generator(seed);
  std::uniform_int_distribution<uint64_t> distribution(
      1, config.random_pattern_area);
  // generate random values
  std::vector<uint64_t> random_values;
  uint64_t sum_random_values = 0;
  for (uint64_t i = 0; i < needed_random_value_count; i++) {
    uint64_t random_value = distribution(generator);
    random_values.push_back(random_value);
    sum_random_values += random_value;
  }
  // scaling random values to fit the area in regard
  std::vector<uint64_t> scaled_random_values;
  for (uint64_t i : random_values) {
    scaled_random_values.push_back(
        (static_cast<double>(i) / sum_random_values) * needed_random_area);
  }
  // if due to rounding the needed fill up sum was not achieved add the
  // remainder 1 by 1 to a randomly chosen value
  uint64_t sum_values =
      std::reduce(scaled_random_values.begin(), scaled_random_values.end());
  if (sum_values < needed_random_area) {
    std::uniform_int_distribution<uint64_t> dist(1,
                                                 scaled_random_values.size());
    while (sum_values < needed_random_area) {
      uint64_t random_pos_in_x = dist(generator) - 1;
      scaled_random_values[random_pos_in_x] =
          scaled_random_values[random_pos_in_x] + 1;
      sum_values++;
    }
  }
  return scaled_random_values;
}

/**
 * @brief    Creates the complete hammer pattern.
 *
 * First, it is determined how often the pattern needs to be repeated to satisfy
 * the needed number of aggressor rows. Then it is checked if there are random
 * positions (x) in the pattern. If there are any, they will be generated by the
 * generate_random_fill_up() method. After that, leading and trailing victims
 * are counted so to be respected in the specified row padding. At last the
 * pattern just gets generated as a boolean vector as described in the
 * description. The random positions (x) are filled up by victims.
 *
 * @param    aggressor_rows      The specified number of aggressor rows.
 */
void HammerPattern::create_pattern(uint32_t aggressor_rows) {
  [[maybe_unused]] std::vector<uint64_t> random_values;
  // check how often the pattern must be repeated to achieve the specified
  // aggressor row count
  uint64_t needed_pattern_repetition =
      std::ceil(config.aggressor_rows / count_char_in_description('a'));
  // check how many random positions are specified
  uint64_t random_positions = count_char_in_description('x');
  // if random positions, generate needed values
  if (random_positions > 0) {
    if (config.random_pattern_area <
        needed_pattern_repetition * description.size())
      log_error_and_exit("Specified random pattern area can not fit the "
                         "specified aggressor rows. Either decrease the "
                         "aggressor rows or increase the random pattern area.");
    uint64_t needed_random_area =
        config.random_pattern_area -
        needed_pattern_repetition * (description.size() - random_positions);
    random_values = generate_random_fill_up(
        needed_random_area, needed_pattern_repetition * random_positions);
  }
  // used to count leading and trailing victims
  auto leading_vs =
      [](auto s) { // generic ("templated") lambda, s can be any iterable
        std::size_t result = 0;
        for (char c : s) {
          if (c == 'v')
            ++result;
          else
            break;
        }
        return result;
      };
  // count leading and trailing victims
  uint64_t leading_victims = leading_vs(description);
  uint64_t trailing_victims = leading_vs(reverse(description));
  uint64_t add_leading_victims =
      std::max(0ul, config.row_padding - leading_victims);
  uint64_t add_trailing_victims =
      std::max(0ul, config.row_padding - trailing_victims);
  uint64_t aggressors = 0;
  // make sure the pattern is empty
  clear();
  // add row padding front
  resize(add_leading_victims, 0);
  // repeat configured pattern until aggressor count is satisfied
  while (aggressors < config.aggressor_rows) {
    for (uint64_t i = 0; i < description.size(); ++i) {
      if (description[i] == 'a') {
        push_back(1);
        ++aggressors;
      } else if (description[i] == 'x') {
        resize(size() + random_values.back(), 0);
        random_values.pop_back();
      } else {
        push_back(0);
      }
    }
  }
  // add row padding back
  resize(size() + add_trailing_victims, 0);
  if (aggressors > aggressor_rows) {
    aggressor_rows = aggressors;
    log_warn("Changed aggressor_rows to ", aggressor_rows,
             " based on hammer_pattern");
  }
}

/**
 * @brief    Counts the occurrence of a character in the hammer pattern
 *           description.
 *
 * @param    character           The regarded character.
 * @return   uint64_t            The occurrences.
 */
uint64_t HammerPattern::count_char_in_description(char8_t character) const {
  return std::count(description.begin(), description.end(), character);
}

/**
 * @brief    Validates the specified hammer pattern description.
 *
 * @return   true                If specified pattern is valid.
 */
bool HammerPattern::validate_description() const {
  static const std::regex hammer_pattern_regex(R"([xva]*a[xva]*)");
  if (!std::regex_match(description, hammer_pattern_regex))
    log_error_and_exit("Invalid value for hammer pattern: "
                       "may only consist of victims (v), aggressors (a) and "
                       "random row distance (x), "
                       "there must be at least one aggressor (a)");
  return true;
}

/**
 * @brief    Construct a new HammerPattern object which creates the hammer
 *           pattern on initialization.
 *
 * @param    description         The description of the hammer pattern to use.
 * @param    aggressor_rows      The number of aggressor rows.
 */
HammerPattern::HammerPattern(const std::string &description,
                             uint32_t &aggressor_rows)
    : description(description) {

#ifdef USE_ASMJIT
  if (config.hammer_algorithm == "blacksmith" && !config.hammer_order.empty())
    config.aggressor_rows =
        *max_element(config.hammer_order.begin(), config.hammer_order.end());
#endif // USE_ASMJIT

  if (description.empty())
    this->description = "va"; // n-sided, the default
  if (validate_description()) {
    create_pattern(aggressor_rows);
  }
}
